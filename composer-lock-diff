#!/usr/bin/env php
<?php

$opts = parseOpts();

$prod = diff('packages', $opts['from'], $opts['to'], $opts['path']);
$dev = diff('packages-dev', $opts['from'], $opts['to'], $opts['path']);

if ($opts['json']) {
    $json_opts = ($opts['pretty']) ? JSON_PRETTY_PRINT : 0;
    print json_encode(array('changes' => $prod, 'changes-dev' => $dev), $json_opts);
    return;
}

$table_opts = ($opts['md']) ? array('capped' => false, 'joint' => '|') : array();

print tableize('Production Changes', $prod, $table_opts);
print tableize('Dev Changes', $dev, $table_opts);

/**
 * @param $key
 * @param $from
 * @param $to
 * @param $base_path
 *
 * @return array
 */
function diff($key, $from, $to, $base_path) {

    $pkgs = array();

    $data = load($from, $base_path);

    foreach($data->$key as $pkg) {
        $pkgs[$pkg->name] = array(version($pkg), 'REMOVED');
    }

    $data = load($to, $base_path);

    foreach($data->$key as $pkg) {
        if (! array_key_exists($pkg->name, $pkgs)) {
            $pkgs[$pkg->name] = array('NEW', version($pkg));
            continue;
        }

        if ($pkgs[$pkg->name][0] == version($pkg)) {
            unset($pkgs[$pkg->name]);
        } else {
            $pkgs[$pkg->name][1] = version($pkg);
        }
    }

    return $pkgs;
}

/**
 * @param $pkg
 *
 * @return bool|null|string
 */
function version($pkg)
{
    $version = null;
    if(substr($pkg->version,0,4) == 'dev-')
    {
        $version = substr($pkg->source->reference,0,7);
    }
    else
    {
        $version = $pkg->version;
    }
    return $version;
}

/**
 * @param       $header
 * @param       $data
 * @param array $opts
 *
 * @return string
 */
function tableize($header, $data, $opts = array()) {
    if (empty($data)) return '';

    $opts = array_merge(array('capped' => true, 'joint' => '+'), $opts);

    $widths = array(maxLength(array_merge(array($header), array_keys($data))));

    for($i = 0; $i < count(reset($data)); $i++) {
        $widths[] = maxLength(array_map(function($k) use ($data, $i) { return $data[$k][$i]; }, array_keys($data)));
    }

    if ($opts['capped']) {
        $lines[] = separatorLine($widths, $opts['joint']);
    }

    $lines[] = tabelizeLine(array($header, 'From', 'To'), $widths);
    $lines[] = separatorLine($widths, $opts['joint']);

    foreach($data as $key => $v) {
        $lines[] = tabelizeLine(array_merge(array($key), $v), $widths);
    }

    if ($opts['capped']) {
        $lines[] = separatorLine($widths, $opts['joint']);
    }

    return implode(PHP_EOL, array_filter($lines)) . PHP_EOL . PHP_EOL;
}

/**
 * @param $widths
 * @param $joint
 *
 * @return string
 */
function separatorLine($widths, $joint) {
    return $joint . implode($joint, array_map(function($n) { return str_repeat('-', $n + 2); }, $widths)) . $joint;
}

/**
 * @param array $array
 *
 * @return mixed
 */
function maxLength(array $array) {
    return max(array_map('strlen', $array));
}

/**
 * @param $data
 * @param $widths
 *
 * @return string
 */
function tabelizeLine($data, $widths) {
    $fields = array();
    $count = max(array(count($data), count($widths)));
    for($i = 0; $i < $count; $i++) {
        $value = ($i >= count($data)) ? '' : $data[$i];
        $width = ($i >= count($widths)) ? strlen($value) : $widths[$i];
        $fields[] = sprintf("%-{$width}s", $value);
    }
    return '| ' . implode(' | ', $fields) . ' |';
}

/**
 * @param        $fileish
 * @param string $base_path
 *
 * @return mixed
 */
function load($fileish, $base_path = '') {
    $orig = $fileish;

    if (empty($base_path)) {
        $base_path = '.' . DIRECTORY_SEPARATOR;
    } else {
        $base_path = rtrim($base_path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;
    }

    if (empty($fileish)) {
        $fileish = $base_path . 'composer.lock';
    }

    if (file_exists($fileish)) {
        return mustDecodeJson(file_get_contents($fileish), $fileish);
    }

    if (strpos($orig, ':') === false) {
        $fileish .= ':' . $base_path . 'composer.lock';
    }

    $lines = '';

    exec('git show '. escapeshellarg($fileish), $lines, $exit);

    if ($exit !== 0) {
        error_log("Error: cannot open $orig or find it in git as $fileish");
        exit(1);
    }

    return mustDecodeJson(implode("\n", $lines), $fileish);
}

/**
 * @param $json
 * @param $context
 *
 * @return mixed
 */
function mustDecodeJson($json, $context) {
    $data = json_decode($json);

    if (empty($data)) {
        error_log("Error: contents from $context does not decode as json");
        exit(1);
    }

    return $data;
}

/**
 * @return array
 */
function parseOpts() {
    $given = getopt('hp:', array('path:', 'from:', 'to:', 'md', 'json', 'pretty', 'help'));

    foreach(array('help' => 'h', 'path' => 'p') as $long => $short) {
        if (array_key_exists($short, $given)) {
            $given[$long] = $given[$short];
            unset($given[$short]);
        }
    }

    if (array_key_exists('help', $given)) {
        usage();
    }

    return array(
        'path' => array_key_exists('path', $given) ? $given['path'] : '',
        'from' => array_key_exists('from', $given) ? $given['from'] : 'HEAD',
        'to' => array_key_exists('to', $given) ? $given['to'] : '',
        'md' => array_key_exists('md', $given),
        'json' => array_key_exists('json', $given),
        'pretty' => version_compare(PHP_VERSION, '5.4.0', '>=') && array_key_exists('pretty', $given),
    );
}

function usage() {
    print <<<EOF
Usage: composer-lock-diff [options]

Options:
  -h --help  Print this message
  --path, -p Base to with which to prefix paths. Default "./"
             E.g. `-p app` would look for HEAD:app/composer.lock and app/composer.lock
  --from     The file, git ref, or git ref with filename to compare from (HEAD:composer.lock)
  --to       The file, git ref, or git ref with filename to compare to (composer.lock)
  --json     Format output as JSON
  --pretty   Pretty print JSON output (PHP >= 5.4.0)
  --md       Use markdown instead of plain text

EOF;

    exit(0);
}
